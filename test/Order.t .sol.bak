// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import "forge-std/Test.sol";
import {console} from "forge-std/console.sol";
import {DeployUtils} from "./utils/DeployUtils.sol";
import {JSONLoader} from "./utils/JSONLoader.sol";
import {StateChecker} from "./utils/StateChecker.sol";
import {SwapUtils} from "./utils/SwapUtils.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IFlashLoanReceiver} from "contracts/IFlashLoanReceiver.sol";
import {ITermMaxMarket, TermMaxMarket, Constants} from "contracts/TermMaxMarket.sol";
import {ITermMaxOrder, TermMaxOrder} from "contracts/TermMaxOrder.sol";
import {MockERC20, ERC20} from "contracts/test/MockERC20.sol";
import {MockPriceFeed} from "contracts/test/MockPriceFeed.sol";
import {IGearingToken} from "contracts/tokens/IGearingToken.sol";
import "contracts/storage/TermMaxStorage.sol";

contract MarketTest is Test {
    using JSONLoader for *;
    DeployUtils.Res res;

    TokenPairConfig tokenPairConfig;
    MarketConfig marketConfig;

    address deployer = vm.randomAddress();
    address sender = vm.randomAddress();
    address treasurer = vm.randomAddress();
    string testdata;

    function setUp() public {
        vm.startPrank(deployer);
        testdata = vm.readFile(string.concat(vm.projectRoot(), "/test/testdata/testdata.json"));

        uint32 maxLtv = 0.89e8;
        uint32 liquidationLtv = 0.9e8;

        tokenPairConfig = JSONLoader.getTokenPairConfigFromJson(treasurer, testdata, ".tokenPairConfig");
        marketConfig = JSONLoader.getMarketConfigFromJson(treasurer, testdata, ".marketConfig");
        res = DeployUtils.deployMarket(deployer, tokenPairConfig, marketConfig, maxLtv, liquidationLtv);
        vm.warp(vm.parseUint(vm.parseJsonString(testdata, ".currentTime")));

        // update oracle
        res.collateralOracle.updateRoundData(
            JSONLoader.getRoundDataFromJson(testdata, ".priceData.ETH_2000_DAI_1.eth")
        );
        res.underlyingOracle.updateRoundData(
            JSONLoader.getRoundDataFromJson(testdata, ".priceData.ETH_2000_DAI_1.dai")
        );

        uint amount = 150e8;
        res.underlying.mint(deployer, amount);
        res.underlying.approve(address(res.tokenPair), amount);
        res.tokenPair.mintFtAndXt(deployer, amount);
        res.ft.transfer(address(res.market), amount);
        res.xt.transfer(address(res.market), amount);

        vm.stopPrank();
    }

    function testBuyFt() public {
        vm.startPrank(sender);

        uint128 underlyingAmtIn = 100e8;
        uint128 minTokenOut = 0e8;
        res.underlying.mint(sender, underlyingAmtIn);
        res.underlying.approve(address(res.market), underlyingAmtIn);

        uint actualOut = vm.parseUint(vm.parseJsonString(testdata, ".expected.testBuyFt.output.netOut"));
        uint fee = vm.parseUint(vm.parseJsonString(testdata, ".expected.testBuyFt.output.fee"));
        StateChecker.MarketState memory expectedState = JSONLoader.getMarketStateFromJson(
            testdata,
            ".expected.testBuyFt.contractState"
        );
        vm.expectEmit();
        emit ITermMaxMarket.BuyToken(
            sender,
            res.ft,
            underlyingAmtIn,
            minTokenOut,
            uint128(actualOut),
            uint128(fee),
            uint128(expectedState.ftReserve),
            uint128(expectedState.xtReserve)
        );
        uint256 netOut = res.market.buyFt(underlyingAmtIn, minTokenOut);

        StateChecker.checkMarketState(res, expectedState);

        assert(netOut == actualOut);
        assert(res.ft.balanceOf(sender) == netOut);

        vm.stopPrank();
    }

    function testBuyFtMinTokenOut() public {
        vm.startPrank(sender);

        uint128 expectedNetOut = uint128(
            vm.parseUint(vm.parseJsonString(testdata, ".expected.testBuyFt.output.netOut"))
        );
        uint128 underlyingAmtIn = 100e8;
        uint128 minTokenOut = expectedNetOut + 1;

        res.underlying.mint(sender, underlyingAmtIn);
        res.underlying.approve(address(res.market), underlyingAmtIn);
        vm.expectRevert(abi.encodeWithSelector(ITermMaxMarket.UnexpectedAmount.selector, minTokenOut, expectedNetOut));
        res.market.buyFt(underlyingAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testBuyFtBeforeMaturity() public {
        vm.startPrank(sender);

        uint128 underlyingAmtIn = 100e8;
        uint128 minTokenOut = 0e8;

        res.underlying.mint(sender, underlyingAmtIn);
        res.underlying.approve(address(res.market), underlyingAmtIn);
        vm.warp(res.tokenPair.config().maturity - 1);
        res.market.buyFt(underlyingAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testBuyFtAfterMaturity() public {
        vm.startPrank(sender);

        uint128 underlyingAmtIn = 100e8;
        uint128 minTokenOut = 0e8;

        res.underlying.mint(sender, underlyingAmtIn);
        res.underlying.approve(address(res.market), underlyingAmtIn);
        vm.warp(res.tokenPair.config().maturity);
        vm.expectRevert(abi.encodeWithSelector(ITermMaxMarket.MarketIsNotOpen.selector));
        res.market.buyFt(underlyingAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testBuyXt() public {
        vm.startPrank(sender);

        uint128 underlyingAmtIn = 5e8;
        uint128 minTokenOut = 0e8;
        res.underlying.mint(sender, underlyingAmtIn);
        res.underlying.approve(address(res.market), underlyingAmtIn);

        uint actualOut = vm.parseUint(vm.parseJsonString(testdata, ".expected.testBuyXt.output.netOut"));
        uint fee = vm.parseUint(vm.parseJsonString(testdata, ".expected.testBuyXt.output.fee"));
        StateChecker.MarketState memory expectedState = JSONLoader.getMarketStateFromJson(
            testdata,
            ".expected.testBuyXt.contractState"
        );
        vm.expectEmit();
        emit ITermMaxMarket.BuyToken(
            sender,
            res.xt,
            underlyingAmtIn,
            minTokenOut,
            uint128(actualOut),
            uint128(fee),
            uint128(expectedState.ftReserve),
            uint128(expectedState.xtReserve)
        );
        uint256 netOut = res.market.buyXt(underlyingAmtIn, minTokenOut);

        StateChecker.checkMarketState(res, expectedState);

        assert(netOut == actualOut);
        assert(res.xt.balanceOf(sender) == netOut);

        vm.stopPrank();
    }

    function testBuyXtMinTokenOut() public {
        vm.startPrank(sender);

        uint128 expectedNetOut = uint128(
            vm.parseUint(vm.parseJsonString(testdata, ".expected.testBuyXt.output.netOut"))
        );
        uint128 underlyingAmtIn = 5e8;
        uint128 minTokenOut = expectedNetOut + 1;

        res.underlying.mint(sender, underlyingAmtIn);
        res.underlying.approve(address(res.market), underlyingAmtIn);
        vm.expectRevert(abi.encodeWithSelector(ITermMaxMarket.UnexpectedAmount.selector, minTokenOut, expectedNetOut));
        res.market.buyXt(underlyingAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testBuyXtBeforeMaturity() public {
        vm.startPrank(sender);

        uint128 underlyingAmtIn = 5e8;
        uint128 minTokenOut = 0e8;

        res.underlying.mint(sender, underlyingAmtIn);
        res.underlying.approve(address(res.market), underlyingAmtIn);
        vm.warp(res.tokenPair.config().maturity - 1);
        res.market.buyXt(underlyingAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testBuyXtAfterMaturity() public {
        vm.startPrank(sender);

        uint128 underlyingAmtIn = 5e8;
        uint128 minTokenOut = 0e8;

        res.underlying.mint(sender, underlyingAmtIn);
        res.underlying.approve(address(res.market), underlyingAmtIn);
        vm.warp(res.tokenPair.config().maturity);
        vm.expectRevert(abi.encodeWithSelector(ITermMaxMarket.MarketIsNotOpen.selector));
        res.market.buyXt(underlyingAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testSellFt() public {
        vm.startPrank(sender);

        uint128 underlyingAmtInForBuyFt = 100e8;
        uint128 minFtOut = 0e8;
        res.underlying.mint(sender, underlyingAmtInForBuyFt);
        res.underlying.approve(address(res.market), underlyingAmtInForBuyFt);
        uint128 ftAmtIn = uint128(res.market.buyFt(underlyingAmtInForBuyFt, minFtOut));
        uint128 minTokenOut = 0e8;
        res.ft.approve(address(res.market), ftAmtIn);

        uint actualOut = vm.parseUint(vm.parseJsonString(testdata, ".expected.testSellFt.output.netOut"));
        uint fee = vm.parseUint(vm.parseJsonString(testdata, ".expected.testSellFt.output.fee"));
        StateChecker.MarketState memory expectedState = JSONLoader.getMarketStateFromJson(
            testdata,
            ".expected.testSellFt.contractState"
        );
        vm.expectEmit();
        emit ITermMaxMarket.SellToken(
            sender,
            res.ft,
            ftAmtIn,
            minTokenOut,
            uint128(actualOut),
            uint128(fee),
            uint128(expectedState.ftReserve),
            uint128(expectedState.xtReserve)
        );
        uint256 netOut = res.market.sellFt(ftAmtIn, minTokenOut);

        StateChecker.checkMarketState(res, expectedState);

        assert(netOut == actualOut);
        assert(res.ft.balanceOf(sender) == 0);
        assert(res.underlying.balanceOf(sender) == netOut);

        vm.stopPrank();
    }

    function testSellFtMinTokenOut() public {
        vm.startPrank(sender);

        uint128 expectedNetOut = uint128(
            vm.parseUint(vm.parseJsonString(testdata, ".expected.testSellFt.output.netOut"))
        );
        uint128 underlyingAmtInForBuyFt = 100e8;
        uint128 minFtOut = 0e8;
        res.underlying.mint(sender, underlyingAmtInForBuyFt);
        res.underlying.approve(address(res.market), underlyingAmtInForBuyFt);
        uint128 ftAmtIn = uint128(res.market.buyFt(underlyingAmtInForBuyFt, minFtOut));
        uint128 minTokenOut = expectedNetOut + 1;

        res.ft.approve(address(res.market), ftAmtIn);
        vm.expectRevert(abi.encodeWithSelector(ITermMaxMarket.UnexpectedAmount.selector, minTokenOut, expectedNetOut));
        res.market.sellFt(ftAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testSellFtBeforeMaturity() public {
        vm.startPrank(sender);

        uint128 underlyingAmtInForBuyFt = 100e8;
        uint128 minFtOut = 0e8;
        res.underlying.mint(sender, underlyingAmtInForBuyFt);
        res.underlying.approve(address(res.market), underlyingAmtInForBuyFt);
        uint128 ftAmtIn = uint128(res.market.buyFt(underlyingAmtInForBuyFt, minFtOut));
        uint128 minTokenOut = 0e8;

        res.ft.approve(address(res.market), ftAmtIn);
        vm.warp(res.tokenPair.config().maturity - 1);
        res.market.sellFt(ftAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testSellFtAfterMaturity() public {
        vm.startPrank(sender);

        uint128 underlyingAmtInForBuyFt = 100e8;
        uint128 minFtOut = 0e8;
        res.underlying.mint(sender, underlyingAmtInForBuyFt);
        res.underlying.approve(address(res.market), underlyingAmtInForBuyFt);
        uint128 ftAmtIn = uint128(res.market.buyFt(underlyingAmtInForBuyFt, minFtOut));
        uint128 minTokenOut = 0e8;

        res.ft.approve(address(res.market), ftAmtIn);
        vm.warp(res.tokenPair.config().maturity);
        vm.expectRevert(abi.encodeWithSelector(ITermMaxMarket.MarketIsNotOpen.selector));
        res.market.sellFt(ftAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testSellXt() public {
        vm.startPrank(sender);

        uint128 underlyingAmtInForBuyXt = 5e8;
        uint128 minXTOut = 0e8;
        res.underlying.mint(sender, underlyingAmtInForBuyXt);
        res.underlying.approve(address(res.market), underlyingAmtInForBuyXt);
        uint128 xtAmtIn = uint128(res.market.buyXt(underlyingAmtInForBuyXt, minXTOut));
        uint128 minTokenOut = 0e8;
        res.xt.approve(address(res.market), xtAmtIn);

        uint actualOut = vm.parseUint(vm.parseJsonString(testdata, ".expected.testSellXt.output.netOut"));
        uint fee = vm.parseUint(vm.parseJsonString(testdata, ".expected.testSellXt.output.fee"));
        StateChecker.MarketState memory expectedState = JSONLoader.getMarketStateFromJson(
            testdata,
            ".expected.testSellXt.contractState"
        );
        vm.expectEmit();
        emit ITermMaxMarket.SellToken(
            sender,
            res.xt,
            xtAmtIn,
            minTokenOut,
            uint128(actualOut),
            uint128(fee),
            uint128(expectedState.ftReserve),
            uint128(expectedState.xtReserve)
        );
        uint256 netOut = res.market.sellXt(xtAmtIn, minTokenOut);

        StateChecker.checkMarketState(res, expectedState);

        assert(netOut == actualOut);
        assert(res.xt.balanceOf(sender) == 0);
        assert(res.underlying.balanceOf(sender) == netOut);

        vm.stopPrank();
    }

    function testSellXtMinTokenOut() public {
        vm.startPrank(sender);

        uint128 expectedNetOut = uint128(
            vm.parseUint(vm.parseJsonString(testdata, ".expected.testSellXt.output.netOut"))
        );
        uint128 underlyingAmtInForBuyXt = 5e8;
        uint128 minXtOut = 0e8;
        res.underlying.mint(sender, underlyingAmtInForBuyXt);
        res.underlying.approve(address(res.market), underlyingAmtInForBuyXt);
        uint128 xtAmtIn = uint128(res.market.buyXt(underlyingAmtInForBuyXt, minXtOut));
        uint128 minTokenOut = expectedNetOut + 1;

        res.xt.approve(address(res.market), xtAmtIn);
        vm.expectRevert(abi.encodeWithSelector(ITermMaxMarket.UnexpectedAmount.selector, minTokenOut, expectedNetOut));
        res.market.sellXt(xtAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testSellXtBeforeMaturity() public {
        vm.startPrank(sender);

        uint128 underlyingAmtInForBuyXt = 5e8;
        uint128 minXtOut = 0e8;
        res.underlying.mint(sender, underlyingAmtInForBuyXt);
        res.underlying.approve(address(res.market), underlyingAmtInForBuyXt);
        uint128 xtAmtIn = uint128(res.market.buyXt(underlyingAmtInForBuyXt, minXtOut));
        uint128 minTokenOut = 0e8;

        res.xt.approve(address(res.market), xtAmtIn);
        vm.warp(res.tokenPair.config().maturity - 1);
        res.market.sellXt(xtAmtIn, minTokenOut);

        vm.stopPrank();
    }

    function testSellXtAfterMaturity() public {
        vm.startPrank(sender);

        uint128 underlyingAmtInForBuyXt = 5e8;
        uint128 minXtOut = 0e8;
        res.underlying.mint(sender, underlyingAmtInForBuyXt);
        res.underlying.approve(address(res.market), underlyingAmtInForBuyXt);
        uint128 xtAmtIn = uint128(res.market.buyXt(underlyingAmtInForBuyXt, minXtOut));
        uint128 minTokenOut = 0e8;

        res.xt.approve(address(res.market), xtAmtIn);
        vm.warp(res.tokenPair.config().maturity);
        vm.expectRevert(abi.encodeWithSelector(ITermMaxMarket.MarketIsNotOpen.selector));
        res.market.sellXt(xtAmtIn, minTokenOut);

        vm.stopPrank();
    }
}
